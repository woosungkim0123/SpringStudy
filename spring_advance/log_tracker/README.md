# 로그 추적기

HTTP 요청 단위로 추적 가능한 로그 추적기를 만드는 것이 목표입니다.

## 쓰레드 로컬(ThreadLocal) - V4에서 사용

### 정의

- 쓰레드 로컬은 해당 쓰레드만 접근할 수 있는 특별한 저장소를 말합니다.
- 쓰레드 로컬을 사용하면 동일한 쓰레드에서만 데이터를 공유할 수 있습니다.
- get() 메서드로 데이터를 읽고 set() 메서드로 데이터를 저장, remove() 메서드로 데이터를 삭제할 수 있습니다.
- 쓰레드 로컬을 모두 사용한 후에는 반드시 remove() 메서드로 데이터를 삭제해야합니다.

```java
public class ThreadLocalService {

    private ThreadLocal<String> threadLocal = new ThreadLocal<>();

    public String logic(String name) {
        threadLocal.set(name); // 쓰레드 로컬에 저장
        // logic ...
        return threadLocal.get(); // 쓰레드 로컬에서 읽기
    }
}
```

### 쓰레드 로컬 사용시 주의사항

웹 애플리케이션 서버(WAS)는 효율적인 자원 관리를 위해 쓰레드 풀을 사용합니다. 

> **쓰레드 풀(Thread Pool)**  
> 
> 쓰레드 생성과 제거에 따른 비용을 줄이기 위해서 사용자의 요청이 들어오면 WAS는 쓰레드 풀에서 쓰레드를 할당받아 작업을 처리하고, 작업이 완료되면 해당 쓰레드를 다시 쓰레드 풀에 반환합니다. 

ThreadLocal을 사용할 때는 쓰레드의 작업이 끝난 후에 반드시 ThreadLocal에 저장된 데이터를 제거해야 합니다.

만약 ThreadLocal에 저장된 데이터를 제거하지 않고 쓰레드를 쓰레드 풀에 반환하게 되면, 그 쓰레드가 다음 번에 다른 작업을 할당받았을 때 ThreadLocal에 이전 작업에서 사용된 데이터가 남아있게 되고 문제가 발생할 수 있습니다.

예를 들어, 사용자 A의 요청을 처리하는 동안 사용자 A의 개인 정보를 ThreadLocal에 저장했다고 가정해봅시다. 
작업 완료 후 이 데이터를 제거하지 않고 쓰레드를 쓰레드 풀에 반환하면, 이 쓰레드가 다음 요청을 처리하게 될 때 ThreadLocal에 남아있는 사용자 A의 정보가 사용자 B에게 노출될 가능성이 있습니다.

이러한 문제를 방지하기 위해, ThreadLocal을 사용한 후에는 반드시 ThreadLocal.remove() 메서드를 호출하여 저장된 데이터를 제거해야 합니다.

## 버전별 변화

### V1

- 로그 트래킹 기능을 사용하여 로그를 남길 수 있도록 하였습니다.

**단점**

- 예외처리시 받을 상태값 때문에 스코프를 넓혀서 처리해야합니다.
- 컨트롤러, 서비스, 리포지토리 각 단계별로 트랜잭션 ID, 레벨을 동기화 처리가 필요합니다.
- 중복된 부분이 많아 코드가 너무 복잡합니다.

### V2

- 파라미터로 트랜잭션 ID와 레벨을 동기화 처리하였습니다.

**단점**

- 비지니스 로직에 관련된 정보가 아닌 단순히 로그를 위한 코드인데 파라미터로 넘겨야합니다.
- 파라미터를 사용하다보니 기존 코드에 추가시 모든 파라미터를 수정해야합니다.
- 로그 처음 시작할 때 `begin`을 호출하고 `beginSync`를 호출해야합니다.
- 다른곳에서 서비스를 처음 호출하는 상황에는 traceId가 없습니다.

### V3

- 로그 추적기의 필드에 트랜잭션ID와 레벨을 저장하여 동기화 처리를 하였습니다.
- 필드에 저장하여 사용하므로 파라미터로 넘기지 않아도 됩니다.

**단점**

- 로그 추적기를 빈으로 등록하여(싱글톤) 사용하므로 동시성 문제가 발생합니다.

> - 동시성 문제는 지역변수에서는 발생하지 않습니다. 지역변수는 쓰레드마다 각각 다른 메모리 영역이 할당됩니다.  
> - 동시성 문제가 발생하는 곳은 같은 인스턴스 필드(주로 싱글톤에서 발생) 또는 static 같은 공용 필드에 접근할 때 발생합니다.
> - 동시성 문제는 값을 읽기만 하면 발생하지 않지만 값을 변경하기 때문에 발생합니다.

```java
public class ConcurrencyExample {
    private static int sharedCounter = 0; // 공용 필드

    public void incrementSharedCounter() {
        sharedCounter++; // 여러 쓰레드가 동시에 접근하면 동시성 문제 발생 가능
    }

    public void methodWithLocalVariable() {
        int localCounter = 0; // 지역변수
        localCounter++; // 각 쓰레드가 독립적으로 사용, 동시성 문제 없음
    }
}
```

### V4

- 쓰레드 로컬을 사용하여 동시성 문제를 해결하였습니다.

