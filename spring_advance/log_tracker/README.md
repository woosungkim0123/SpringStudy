# 로그 추적기

HTTP 요청 단위로 추적 가능한 로그 추적기를 만드는 것이 목표입니다.

## 버전별 변화

### V1

- 로그 트래킹 기능을 사용하여 로그를 남길 수 있도록 하였습니다.

**단점**

- 예외처리시 받을 상태값 때문에 스코프를 넓혀서 처리해야합니다.
- 컨트롤러, 서비스, 리포지토리 각 단계별로 트랜잭션 ID, 레벨을 동기화 처리가 필요합니다.
- 중복된 부분이 많아 코드가 너무 복잡합니다.

### V2

- 파라미터로 트랜잭션 ID와 레벨을 동기화 처리하였습니다.

**단점**

- 비지니스 로직에 관련된 정보가 아닌 단순히 로그를 위한 코드인데 파라미터로 넘겨야합니다.
- 파라미터를 사용하다보니 기존 코드에 추가시 모든 파라미터를 수정해야합니다.
- 로그 처음 시작할 때 `begin`을 호출하고 `beginSync`를 호출해야합니다.
- 다른곳에서 서비스를 처음 호출하는 상황에는 traceId가 없습니다.

### V3

- 로그 추적기의 필드에 트랜잭션ID와 레벨을 저장하여 동기화 처리를 하였습니다.
- 필드에 저장하여 사용하므로 파라미터로 넘기지 않아도 됩니다.

**단점**

- 로그 추적기를 빈으로 등록하여(싱글톤) 사용하므로 동시성 문제가 발생합니다.

> - 동시성 문제는 지역변수에서는 발생하지 않습니다. 지역변수는 쓰레드마다 각각 다른 메모리 영역이 할당됩니다.  
> - 동시성 문제가 발생하는 곳은 같은 인스턴스 필드(주로 싱글톤에서 발생) 또는 static 같은 공용 필드에 접근할 때 발생합니다.
> - 동시성 문제는 값을 읽기만 하면 발생하지 않지만 값을 변경하기 때문에 발생합니다.

```java
public class ConcurrencyExample {
    private static int sharedCounter = 0; // 공용 필드

    public void incrementSharedCounter() {
        sharedCounter++; // 여러 쓰레드가 동시에 접근하면 동시성 문제 발생 가능
    }

    public void methodWithLocalVariable() {
        int localCounter = 0; // 지역변수
        localCounter++; // 각 쓰레드가 독립적으로 사용, 동시성 문제 없음
    }
}
```


